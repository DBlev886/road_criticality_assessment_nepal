import sys
import osmnx as ox
import networkx as nx
import geopandas as gpd
import rasterio as rio
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import pandas as pd
from pyproj import CRS
import contextily as ctx
from osgeo import gdal
import numpy as np
from shapely.geometry import Point, MultiPoint, MultiLineString, MultiPolygon
from shapely import speedups

#%matplotlib inline
ox.__version__


########## get data from OSM and define aoi
# define study area, fetch OSM street network data, project and plot it + simplify network topology and consolidate intersections
study_area = (["Beni, Nepal", "Jaljala, Nepal"])
network = ox.graph_from_place(study_area, network_type="drive", buffer_dist=500, clean_periphery=True)
#fig, ax = ox.plot_graph(network, node_color="r")

# Project the data
network_proj = ox.project_graph(network)
network_gdf = gpd.GeoDataFrame(network_proj, crs="EPSG:32644")
#fig, ax = ox.plot_graph(network, bgcolor='k', node_size=30, node_color='#999999', node_edgecolor='none', node_zorder=2,
#                        edge_color='#555555', edge_linewidth=1.5, edge_alpha=1)
network_nodes, network_edges = ox.graph_to_gdfs(network_proj, nodes=True, edges=True)
#network_edges = network_edges.dropna()

centrality = nx.closeness_centrality(nx.line_graph(network_proj))
network_edges['centrality'] = centrality.values()

'''quant_one = network_edges['centrality'].quantile(.2)
quant_two = network_edges['centrality'].quantile(.4)
quant_three = network_edges['centrality'].quantile(.6)
quant_four = network_edges['centrality'].quantile(.8)
quant_five = network_edges['centrality'].quantile(1)

quantile_frame = network_edges['centrality'].quantile(q=[0.2, 0.4, 0.6, 0.8])'''
network_edges['centr_score'] = pd.qcut(network_edges['centrality'], q=5, labels=[1,2,3,4,5])

#df['quartile'] = quantile_ranks


#if network_edges['centrality'].quantile() <= quant_one:
#    network_edges['centr_score'] = 1 
'''elif network_edges['centrality'].quantile() > quant_one:
    if network_edges['centrality'].quantile() <= quant_two:
        network_edges['centr_score'] = 2
elif network_edges['centrality'].quantile() > quant_two:
    if network_edges['centrality'].quantile() <= quant_three:
        network_edges['centr_score'] = 3
elif network_edges['centrality'].quantile() > quant_three:
    if network_edges['centrality'].quantile() <= quant_four:
        network_edges['centr_score'] = 4
else:
    network_edges['centr_score'] = 5
'''
'''
###################### ELEVATION GRADES ### not sure if this is useful eventually
########## node elevations and edge grades
# add node elevations from a single raster file
raster_path = "ASTGTMV003_N28E083_dem.tif"
network_elev = ox.elevation.add_node_elevations_raster(network_proj, raster_path)
assert not np.isnan(np.array(network_elev.nodes(data="elevation"))[:, 1]).any()
# add edge grades and their absolute values
network_elev = ox.elevation.add_edge_grades(network_elev, add_absolute=True)
# plot nodes by elevation and get one color for each node, by elevation, then plot the network
nc = ox.plot.get_node_colors_by_attr(network_elev, "elevation", cmap="plasma")
fig, ax = ox.plot_graph(network_elev, node_color=nc, node_size=5, edge_color="#333333", bgcolor="k")

###################### CENTRALITY INDICES
# node closeness centrality
node_centrality = nx.closeness_centrality(network_proj)
# plot it
df = pd.DataFrame(data=pd.Series(node_centrality).sort_values(), columns=['cc'])
df['colors'] = ox.plot.get_colors(n=len(df), cmap='inferno', start=0.2)
df = df.reindex(network_proj.nodes())
nc = df['colors'].tolist()
fig, ax = ox.plot_graph(network_proj, bgcolor='k', node_size=30, node_color=nc, node_edgecolor='none', node_zorder=2,
                        edge_color='#555555', edge_linewidth=1.5, edge_alpha=1)


# edge closeness centrality: convert graph to a line graph so edges become nodes and vice versa

# list of edge values for the orginal graph
#ev = [network_gdf['centrality'][edge + (0,)] for edge in network_proj.edges()]

# color scale converted to list of colors for graph edges
norm = colors.Normalize(vmin=min(ev)*0.8, vmax=max(ev))
cmap = cm.ScalarMappable(norm=norm, cmap=cm.inferno)
ec = [cmap.to_rgba(cl) for cl in ev]

# color the edges in the original graph with closeness centralities in the line graph
fig, ax = ox.plot_graph(network_proj, bgcolor='k', node_size=0, node_color='w', node_edgecolor='gray', node_zorder=2,
                        edge_color=ec, edge_linewidth=1.5, edge_alpha=1)

###################### BUFFER EDGES
# Retrieve nodes and edges from graph and add to old file
network_nodes, network_edges = ox.graph_to_gdfs(network_proj, nodes=True, edges=True)
#edge_centrality1 = gpd.GeoDataFrame(edge_centrality, crs="EPSG:32644")


# buffer edges
buffered = edges_proj.to_crs(epsg=32644)
buffered = edges_proj.buffer(100, cap_style=2)
buffered = gpd.GeoDataFrame(geometry=gpd.GeoSeries(buffered))
buffered = buffered.dropna(axis=0, how="any", thresh=None, subset=None, inplace=False)
#buffered.plot()
outfp = 'C:/Users/Danny/Beni/edges.shp'
buffered.to_file(outfp)


# Get place boundary related to the place name as a geodataframe
## buffer distance important to connect roads on the outside and to allow connectivitiy between administrative units, where roads usually tend to be
AOI = ox.geocode_to_gdf(study_area, buffer_dist=2000)
AOI = AOI.to_crs(epsg=32644)
AOI.to_file("AOI.shp")
#AOI.plot()


###################### POPULATION COUNT
########## define mask and mask raster data ##### code too complicated
ds = gdal.Open("world_pop_npl_ppp_2020_UNadj.tif")
#array = ds.GetRasterBand(1).ReadAsArray()
#plt.imshow(array)
#plt.colorbar()
#print(ds.GetGeoTransform())
#print(ds.GetProjection())

dsClip = gdal.Warp("world_pop_npl_ppp_2020_UNadj_clipped.tif", ds, cutlineDSName = "AOI.shp",
                   cropToCutline = True, dstNodata = np.nan, dstSRS='EPSG:32644')
#array = dsClip.GetRasterBand(1).ReadAsArray()
#plt.imshow(array)
#plt.colorbar()


with rio.open('C:/Users/Danny/Beni/world_pop_npl_ppp_2020_UNadj_clipped.tif') as dataset:
    val = dataset.read(1) # band 1
    no_data=dataset.nodata
    geometry = [Point(dataset.xy(x,y)[0],dataset.xy(x,y)[1]) for x,y in np.ndindex(val.shape) if val[x,y] != no_data]
    v = [val[x,y] for x,y in np.ndindex(val.shape) if val[x,y] != no_data]
    df = gpd.GeoDataFrame({'geometry':geometry,'data':v})
    if buffered.crs != df.crs:
        df = df.set_crs(buffered.crs, inplace=True)

df = df.dropna(axis=0, how="any", thresh=None, subset=None, inplace=False)
df.to_file("population_points.shp")


#### boost spatial query with R-Tree instead of spatial join
spatial_index = df.sindex
possible_matches_index = list(spatial_index.intersection(buffered.bounds))
possible_matches = df.iloc[possible_matches_index]
precise_matches = possible_matches[possible_matches.intersects(buffered)]

buffered_with_df = gpd.sjoin(df, buffered, how='inner', op='within', lsuffix='left', rsuffix='right')
buffered_with_df.to_file("population_edges.shp")

stats_buffered = buffered_with_df.groupby(by="index_right1").agg('mean')

'''
