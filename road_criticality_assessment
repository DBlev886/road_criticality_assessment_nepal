import sys
import osmnx as ox
import networkx as nx
import geopandas as gpd
import rasterio as rio
from rasterio.plot import show
from rasterio.plot import show_hist
import rasterstats
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
import pandas as pd
from pyproj import CRS
import contextily as ctx
from osgeo import gdal
import numpy as np
from shapely.geometry import Point, MultiPoint, MultiLineString, MultiPolygon
from shapely import speedups


########## get data from OSM and define aoi
# define study area, fetch OSM street network data, project and plot it + simplify network topology and consolidate intersections
study_area = (["Beni, Nepal", "Jaljala, Nepal"])
network = ox.graph_from_place(study_area, network_type="drive", buffer_dist=500, clean_periphery=True)
#fig, ax = ox.plot_graph(network, node_color="r")

# Project the data
network_proj = ox.project_graph(network)
network_gdf = gpd.GeoDataFrame(network_proj, crs="EPSG:32644")
#fig, ax = ox.plot_graph(network, bgcolor='k', node_size=30, node_color='#999999', node_edgecolor='none', node_zorder=2,
#                        edge_color='#555555', edge_linewidth=1.5, edge_alpha=1)
network_nodes, network_edges = ox.graph_to_gdfs(network_proj, nodes=True, edges=True)
#network_edges = network_edges.dropna()

############ get Centrality values and assign scores
centrality = nx.closeness_centrality(nx.line_graph(network_proj))
network_edges['centrality'] = centrality.values()
# qcut: quantile-based discretization to assign scores from 1 to 5 to centrality values
network_edges['centr_score'] = pd.qcut(network_edges['centrality'], q=5, labels=[1,2,3,4,5])

# Get place boundary related to the place name as a geodataframe
## buffer distance important to connect roads on the outside and to allow connectivitiy between administrative units, where roads usually tend to be
AOI = ox.geocode_to_gdf(study_area, buffer_dist=2000)
AOI = AOI.to_crs(epsg=32644)
AOI = AOI.dissolve()

###################### BUFFER EDGES
# buffer edges
buffered = network_edges.buffer(100, cap_style=2)
buffered = gpd.GeoDataFrame(geometry=gpd.GeoSeries(buffered))
#buffered = buffered.dropna(axis=0, how="any", thresh=None, subset=None, inplace=False)
#buffered.plot()

###################### POPULATION COUNT
########## define mask and mask raster data ##### code too complicated and output has to be changed for automatization
#ds = gdal.Open("world_pop_npl_ppp_2020_UNadj.tif")
#array = ds.GetRasterBand(1).ReadAsArray()

filepath = r"C:\Users\Danny\Beni\world_pop_npl_ppp_2020_UNadj.tif"

# Open the file:
pop_raster = gdal.Open(filepath)

# Check type of the variable 'raster'
type(pop_raster)

#plt.imshow(array)
#plt.colorbar()
#print(ds.GetGeoTransform())
#print(ds.GetProjection())

# clip population raster with AOI
dsClip = gdal.Warp("C:/Users/Danny/Beni/world_pop_npl_ppp_2020_UNadj_clipped.tif", pop_raster, cutlineDSName = AOI,
                   cropToCutline = True, dstNodata = np.nan, dstSRS='EPSG:32644')
#array = dsClip.GetRasterBand(1).ReadAsArray()
#plt.imshow(array)
#plt.colorbar()

# read clipped population raster and assign values to numpy nd array
pop_count =  rio.open("C:/Users/Danny/Beni/world_pop_npl_ppp_2020_UNadj_clipped.tif")
pop_count_arrey = pop_count.read(1)

affine = pop_count.transform

# calculating zonal statistics
pop_mean = rasterstats.zonal_stats(buffered, pop_count_arrey, affine = affine,
                                            stats = ['mean'],
                                            geojson_out = True)

# extract average population data from list
pop_mean_list = []
i = 0

while i < len(pop_mean):
    pop_mean_list.append(pop_mean[i]['properties'])
    i = i + 1

# transfer information from list to DataFrame
new_list = pd.DataFrame(pop_mean_list)
#### Value is in new_list but cannot be transfered to network_edges for some reason
network_edges['pop_mean'].columns=new_list['mean']
#network_edges['pop_mean'] = new_list['mean']

#while i < len(network_edges):
#    network_edges['pop_mean'].append(new_list[i]['mean'])
#    i = i + 1
#network_edges['pop_mean']
network_edges


'''
###################### ELEVATION GRADES ### not sure if this is useful eventually
########## node elevations and edge grades
# add node elevations from a single raster file
raster_path = "ASTGTMV003_N28E083_dem.tif"
network_elev = ox.elevation.add_node_elevations_raster(network_proj, raster_path)
assert not np.isnan(np.array(network_elev.nodes(data="elevation"))[:, 1]).any()
# add edge grades and their absolute values
network_elev = ox.elevation.add_edge_grades(network_elev, add_absolute=True)
# plot nodes by elevation and get one color for each node, by elevation, then plot the network
nc = ox.plot.get_node_colors_by_attr(network_elev, "elevation", cmap="plasma")
fig, ax = ox.plot_graph(network_elev, node_color=nc, node_size=5, edge_color="#333333", bgcolor="k")

###################### CENTRALITY INDICES
# node closeness centrality
node_centrality = nx.closeness_centrality(network_proj)
# plot it
df = pd.DataFrame(data=pd.Series(node_centrality).sort_values(), columns=['cc'])
df['colors'] = ox.plot.get_colors(n=len(df), cmap='inferno', start=0.2)
df = df.reindex(network_proj.nodes())
nc = df['colors'].tolist()
fig, ax = ox.plot_graph(network_proj, bgcolor='k', node_size=30, node_color=nc, node_edgecolor='none', node_zorder=2,
                        edge_color='#555555', edge_linewidth=1.5, edge_alpha=1)


# edge closeness centrality: convert graph to a line graph so edges become nodes and vice versa

# list of edge values for the orginal graph
#ev = [network_gdf['centrality'][edge + (0,)] for edge in network_proj.edges()]

# color scale converted to list of colors for graph edges
norm = colors.Normalize(vmin=min(ev)*0.8, vmax=max(ev))
cmap = cm.ScalarMappable(norm=norm, cmap=cm.inferno)
ec = [cmap.to_rgba(cl) for cl in ev]

# color the edges in the original graph with closeness centralities in the line graph
fig, ax = ox.plot_graph(network_proj, bgcolor='k', node_size=0, node_color='w', node_edgecolor='gray', node_zorder=2,
                        edge_color=ec, edge_linewidth=1.5, edge_alpha=1)

#### boost spatial query with R-Tree instead of spatial join ???

'''
